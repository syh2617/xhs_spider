{
  "props": {
    "pageProps": {
      "id": 1684,
      "title": "面试刷题总结（十一） - 排序和二分搜索",
      "status": "publish",
      "published": 1429459200000,
      "created": 1429459200000,
      "modified": 1664851334000,
      "content": "\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e二分查找\u003c/h2\u003e\u003cp class=\"my-4 font-light\"\u003e经典的二分查找也分为了三个问题：\u003c/p\u003e\u003col class=\"my-4 ml-4 font-light list-decimal\"\u003e\u003cli class=\"\"\u003e在没有重复元素的数组中找到对应元素\u003c/li\u003e\u003cli class=\"\"\u003e在有重复元素的数组中找到上界\u003c/li\u003e\u003cli class=\"\"\u003e在有重复元素的数组中找到下界\u003c/li\u003e\u003c/ol\u003e\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e二分查找例题\u003c/h2\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eLeetCode 33 搜索旋转排序数组\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eLeetCode 34 在排序数组中查找元素的第一个和最后一个位置\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eRotated Sorted Array\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eMountain Sequence\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eOOXX 问题\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003eSearch Sorted Matrix\u003c/h3\u003e\u003ch3 class=\"my-2 font-semibold \"\u003e值得注意的细节\u003c/h3\u003e\u003cp class=\"my-4 font-light\"\u003e使用 \u003ccode class=\"px-1 bg-gray-100 border-2 rounded\"\u003eleft + (right - left) / 2\u003c/code\u003e 而不要使用 \u003ccode class=\"px-1 bg-gray-100 border-2 rounded\"\u003e(left + right) / 2\u003c/code\u003e, 避免溢出。\u003c/p\u003e\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e排序\u003c/h2\u003e\u003cp class=\"my-4 font-light\"\u003e适合链表的排序算法：选择排序\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003e如果需要一次按照两个键排序，必须使用稳定的排序算法。\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003e排序算法选择准则：\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003e1．待排序的记录数目 n 的大小；\n2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；\n3．关键字的结构及其分布情况；\n4．对排序稳定性的要求。\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003ebloomfilter 错误率 (1-1/n)^k n 为数组大小，k 为 hash 个数\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003exor filter: \u003ca class=\"underline\" href=\"https://stackoverflow.com/questions/67527507/what-is-an-xor-filter\" title=\"undefined\"\u003ehttps://stackoverflow.com/questions/67527507/what-is-an-xor-filter\u003c/a\u003e\u003c/p\u003e\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e堆\u003c/h2\u003e\u003cp class=\"my-4 font-light\"\u003e堆可以分成两种：大根堆和小根堆。他们两个的区别是显然的，不多说了，下面的讨论以大根堆为例。\u003c/p\u003e\u003cp class=\"my-4 font-light\"\u003e堆的两种基本操作：向上调整和向下调整。\u003c/p\u003e\u003cul class=\"my-4 ml-4 font-light list-disc\"\u003e\u003cli class=\"\"\u003e向上调整指的是，在堆的尾部插入一个元素，然后再使堆满足性质的行为，也就是需要这个元素向上找到他的位置；\u003c/li\u003e\u003cli class=\"\"\u003e向下调整指的是，当堆顶的一个元素可能不满足性质的时候，让这个元素向下找到他的位置。\u003c/li\u003e\u003c/ul\u003e\u003cpre class=\"text-sm bg-gray-100 my-4 p-2 overflow-x-auto\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e# 这里我们以 0 为索引起点\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eleft\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e): \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eright\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e): \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * i + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ei\u003c/span\u003e): \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (i-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) // \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eh, i\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u0026quot;向上比较简单，因为只需要考虑父元素就行了\u0026quot;\u0026quot;\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e i \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e h[i] \u0026gt; h[parent(i)]:\n        h[i], h[parent(i)] = h[parent(i)], h[i]\n        i = parent(i)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edown\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eh, i, n\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u0026quot;向下稍微复杂一些，因为需要考虑两个子节点\u0026quot;\u0026quot;\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e left(i) \u0026lt;= n:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e right(i) \u0026lt;= n \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e h[right(i)] \u0026gt; h[left(i)]:\n            j = right(i)\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n            j = left(i)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e h[j] \u0026lt;= h[i]:\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n        h[i], h[j] = h[j], h[i]\n        i = j\u003c/code\u003e\u003c/pre\u003e\u003ch3 class=\"my-2 font-semibold \"\u003e构建堆\u003c/h3\u003e\u003cp class=\"my-4 font-light\"\u003e有了以上两种基本操作，构建堆也就可以按两种方式：\u003c/p\u003e\u003cul class=\"my-4 ml-4 font-light list-disc\"\u003e\u003cli class=\"\"\u003e从前往后构建，也就是把每一个新加入的元素理解为从后方插入，直接向上调整就行了\u003c/li\u003e\u003cli class=\"\"\u003e从后往前构建，这样其实相当于把左右两个子堆合并为一个新堆，但是新堆的根节点不一定满足堆续，只需要向下调整根节点就行了\u003c/li\u003e\u003c/ul\u003e\u003cp class=\"my-4 font-light\"\u003e两种方法的代码分别是：\u003c/p\u003e\u003cpre class=\"text-sm bg-gray-100 my-4 p-2 overflow-x-auto\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild_heap_forward\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eh\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(h)):\n        up(h, i)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild_heap_backward\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eh\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(h)):\n        down(h, \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(h) - i)\u003c/code\u003e\u003c/pre\u003e\u003ch3 class=\"my-2 font-semibold \"\u003e堆排\u003c/h3\u003e\u003cp class=\"my-4 font-light\"\u003e有了上面的代码，那么我们的堆排代码也就很简单了\u003c/p\u003e\u003cpre class=\"text-sm bg-gray-100 my-4 p-2 overflow-x-auto\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-attribute\"\u003edef\u003c/span\u003e heap_sort(h):\n    \u003cspan class=\"hljs-attribute\"\u003ebuild_heap\u003c/span\u003e(h)\n    \u003cspan class=\"hljs-attribute\"\u003efor\u003c/span\u003e i in range(len(h) - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e):\n        \u003cspan class=\"hljs-attribute\"\u003eh\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], h[i] = h[i], h[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n        \u003cspan class=\"hljs-attribute\"\u003edown\u003c/span\u003e(h, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e字符串排序\u003c/h2\u003e\u003cp class=\"my-4 font-light\"\u003e可以使用低位优先排序和高位优先排序两种方法。低位优先排序就直接排就好了，高位优先排序很自然是一种递归算法，首先排序高位，然后排序\u003ccode class=\"px-1 bg-gray-100 border-2 rounded\"\u003es[1:]\u003c/code\u003e。\u003c/p\u003e\u003ch2 class=\"my-2 font-semibold text-xl\"\u003e参考资料\u003c/h2\u003e\u003col class=\"my-4 ml-4 font-light list-decimal\"\u003e\u003cli class=\"\"\u003e\u003ca class=\"underline\" href=\"https://leetcode.com/problems/sort-an-array/discuss/357592/O(n-log-n)-time-O(1)-space-HeapSort\" title=\"undefined\"\u003ehttps://leetcode.com/problems/sort-an-array/discuss/357592/O(n-log-n)-time-O(1)-space-HeapSort\u003c/a\u003e\u003c/li\u003e\u003cli class=\"\"\u003e\u003ca class=\"underline\" href=\"https://blog.5udou.cn/#/blog/detail/Cong-libuvYuan-Ma-Zhong-Xue-Xi-Zui-Xiao-Er-Cha-Dui-24\" title=\"null\"\u003eLibUV 中的最小二叉堆\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e"
    },
    "__N_SSG": true
  },
  "page": "/note/[id]",
  "query": {
    "id": "1684"
  },
  "buildId": "BCqlu1POmovEULaBOvjuU",
  "isFallback": false,
  "gsp": true,
  "scriptLoader": []
}